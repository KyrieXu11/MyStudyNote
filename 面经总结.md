# 放一些可能出现的面试题目

## JVM

## MySQL

## Java

### 接口和抽象类的区别

## Redis

## 多线程

### synchronized的底层实现原理

底层使用MonitorEnter和MonitorExit来控制锁的获取以及释放。提一句，wait和notify也是通过这种方式来进行线程的唤醒和堵塞，所以wait才只能在同步块中进行调用。

锁的分类：无锁、偏向锁、轻量级锁、重量级锁。

下面就是对象头中的Mark Word的存储内容

| 锁状态   | 29 bit 或 61 bit             | 1 bit 是否是偏向锁？       | 2 bit 锁标志位 |
| -------- | ---------------------------- | -------------------------- | -------------- |
| 无锁     |                              | 0                          | 01             |
| 偏向锁   | 线程ID                       | 1                          | 01             |
| 轻量级锁 | 指向栈中锁记录的指针         | 此时这一位不用于标识偏向锁 | 00             |
| 重量级锁 | 指向互斥量（重量级锁）的指针 | 此时这一位不用于标识偏向锁 | 10             |
| GC标记   |                              | 此时这一位不用于标识偏向锁 | 11             |

无锁就是没有锁的意思。

偏向锁：锁总是偏向于第一次获取锁的线程。在锁的对象头的mark word中，有一个记录偏向锁的位置，存放的是线程的ID。如果一个线程遇见锁（synchronized）了，会去检查锁的对象头的偏向锁的记录是不是当前的线程ID，如果是的话，就直接略过锁不用CAS来进入和退出锁，如果不是的话，就表明有线程竞争，那就使用CAS来替换偏向锁记录的线程ID为当前的线程ID，成功了的话就不会进行锁升级，如果失败的话就进行锁升级。

轻量级锁：不存在锁竞争，没有线程堵塞。栈的局部变量表中有存放对象的引用，也可以理解为一种指针。所以在检测到是轻量级锁的情况之后，就用CAS来改变轻量级中指向栈帧的锁记录的指针，如果成功了就表示当前的线程获得到了锁，如果失败了就一直自旋等待获取锁的线程释放锁，但是不会一直自旋，如果自旋了很久就升级成重量级锁。

重量级锁：使用操作系统的互斥量（mutex）实现的

# 2020.6.5 欢聚时代凉经

简历上写了一些大学的必修课，比如操作系统，计算机网络，组成原理

## 操作系统

### 虚拟内存是什么？

多个进程是共享cpu和内存的，所以操作系统使用了虚拟内存来管理内存，防止内存泄漏。虚拟内存就是操作系统对主存概念的抽象。

虚拟内存为每一个进程提供了一个一致的、完整的地址空间，让每一个进程都产生了一种觉得自己是在独享内存的错觉。

虚拟内存有下面三个好处：

+ 把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中按需缓存。
+ 为每一个进程都提供了一个独立的地址空间，保护每一个进程的地址空间不会被别的进程破坏。

### 多核CPU如何保证执行的正确性？

## 计算机网络

### TCP和UDP的区别

+ TCP是可靠传输，UDP不保证可靠传输
+ TCP是面向字节流的，UDP是面向报文的
+ TCP需要连接，UDP不需要连接
+ TCP有拥塞控制，UDP没有
+ TCP是点对点通信，而UDP可以1对1，也可以1对多
+ TCP首部较长并且是变长的，UDP首部只有8个字节并且是定长的

### TCP如何保证可靠传输的

+ 超时重传
+ 分组交换
+ 拥塞控制

### TCP的三次握手和四次挥手

#### 三次握手

客户端发送一个SYN报文（SYN=1），同时会初始化一个序号，这个序号是随机的（seq=x），服务端如果接受到这个SYN的报文会响应给客户端一个ACK报文（ACK=1），并且服务端也会初始化一个随机的序号（seq=y），并且返回的ack（小写的）= 客户端发送的序号+1（ack=x+1），客户端收到服务端的ACK响应报文之后，就可以真正的开始发送数据了，此时也会响应服务端一个ACK报文（ACK=1，ack=y+1）。

#### 为什么需要三次握手

+ 避免历史连接
+ 同步双方的序列号
+ 确定双方有接收和发送报文的能力

#### 四次挥手

客户端发送一个FIN报文，服务端收到这个报文之后发送一个ACK报文，此时服务端可以继续发送数据，如果服务端发送完成之后想关闭连接，会发送一个FIN报文给客户端，客户端收到这个报文之后，也会响应一个ACK报文给服务端，到此四次挥手完成。

## JAVA

### HashMap的底层数据结构，是线程安全的吗？

Hashmap的底层数据结构是数组+链表+红黑树，并且数组（哈希桶）的默认容量为16，负载因子是0.75，也就是说如果节点数（键值对数量）超过了16*0.75个就会扩容。

#### 扩容

扩容是只对哈希桶进行扩容，实际上的键值对数量和扩容没有关系。

扩容的过程是：创建一个长度为原来的数组长度*2的数组，然后将原来的数组元素一个一个rehash放进新的数组，rehash在jdk1.8的时候是采用这种方式：由于每次扩容数组的元素都是2倍增长的，所以新的数组容量比原来的数组容量多了一位而已，如果新增的那一位为0，则该节点在新的数组中的位置和原来数组中的位置一样，否则为原来的数组位置+原来数组长度大小。

比如原来的容量为16，(16-1)=1111，扩容之后的大小为32，(32-1)=11111，然后用原来的hash值&新的容量，如果多出来的那位为1，则为原来的数组位置+原来的数组长度，否则不变。

![](https://pic2.zhimg.com/80/a285d9b2da279a18b052fe5eed69afe9_720w.png)

#### get

根据key计算出hash，然后用这个hash^(n-1)来计算在数组中的位置，比较头节点，如果相等就返回，如果不相等就遍历链表或者红黑树，直到找到对应的key所对应的value

计算hash的方法是：key==null?key.hashcode^(key.hashcode>>16)，这个方法是一个扰动函数，能够减少hash碰撞

#### put

首先判断数组是否为空，如果为空的话就进行扩容（初始化长度为16的数组）

如果不为空，就计算hash值并且判断该位置上有没有元素，如果有元素的话，就判断key值是否相等（hashcode和equals），如果相等就直接覆盖，如果不相等就遍历后边的元素。如果没有元素的话就新建一个节点。如果一条链表的元素个数大于8，那么就转换成红黑树，不过有一个前提就是要整个map的所有键值对的个数都要大于64，不然就执行扩容。红黑树变回链表的条件是元素个数小于等于6个。

### ConcurrentHashMap如何保证线程安全的



## Jvm

### 运行时数据区有哪些

### 哪些是线程私有哪些的线程公有的

### 方法区存放的有哪些东西

### 创建一个对象的过程

### 如何知道这个对象是哪个类型的

## MySQL

### mysql的事务的四大特性

### 事务的隔离性有哪一些

### 默认的事务隔离性是什么

### 表锁和行锁有什么区别

## Redis

### 基本的数据结构有哪些

string set hash zset hyperloglog 布隆过滤器

### 布隆过滤器实现的原理

每次添加key的时候使用3个函数，让得到的值余上数组长度，然后将对应的位置置为1，添加就完成了。过滤就反其道而行之，看对应的位置是否为0，有一个为0的话，那么就表示不存在这个key

### 布隆过滤器的使用场景

推送的时候可以使用布隆过滤器来避免推送了用户的浏览历史内容

### string的底层实现

数组，类似于ArrayList的底层实现

## 我问的问题

为什么不问spring的那些东西

### 回答

只要基础好，spring给两天时间就能会，深入的得看源码

# 2020.6.29 招银网络科技一面

## JVM

### 说一下JVM的内存模型

### 垃圾回收的算法有哪些

### 讲一个熟悉的垃圾回收算法

### 类加载的过程

### 双亲委派模型

### 自己写的程序由哪个类加载器加载

## MySQL

### 事务的四个属性解释一下

### innodb的默认索引是什么？

### 为什么会选择B+树？

### B+树的缺点

## Redis

### 常用的数据结构

### 这些数据结构的内部编码有哪些

https://www.cnblogs.com/yangmingxianshen/p/8054094.html

使用object encoding {key} 查看编码

String有 **int**(value是数字，并且不带引号的时候的编码)，**embstr**(字符串比较短的时候的编码)，**raw**(字符串比较长的编码)

Hash有**ziplist**：当field个数比较少且没有大的value时，内部编码为ziplist；**hashtable**：当有value大于64个字节或者当field个数超过512，内部编码会由ziplist变为hashtable

list有**ziplist**：当元素个数较少且没有大元素时，为ziplist；**linkedlist**：当元素个数超过512个或者当某个元素超过64个字节，内部编码变为linkedlist

set有**intset**：整数集合，当元素比较少的时候并且都是整数的时候，内部编码是intset ；**hashtable**：当元素个数超过512个，或者某个元素不为整数的时候，内部编码为hashtable

zset有

### 一般使用Redis干嘛

缓存

## Spring

### springboot 2.x 官方推荐使用构造器注入，为什么？

### SpringBoot的启动流程（自己补充的）

### Spring事务怎么用的？有哪些传播机制

### @Transactional能用在private方法上吗？为什么？


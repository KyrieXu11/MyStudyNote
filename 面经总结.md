# 放一些可能出现的面试题目

## JVM

## MySQL

## Java

### 接口和抽象类的区别

## Redis

### 使用list做消息队列会遇到什么问题

如果队列为空，那么使用lpop/rpop 会导致cpu空转，如果有很多客户端都在发送这个指令的话，Redis的QPS会很高。解决办法：让客户端的线程休眠一定的时间。

但是休眠线程之后会导致消息接收有延迟，所以使用阻塞pop也就是brpop/blpop，没有数据会自动休眠，有数据会立刻醒过来。

但是如果阻塞的太久了，redis会认为这个连接是一个闲置连接，会自动断开这个连接，断开之后再使用brpop/blpop会抛出异常。

## 多线程

### synchronized的底层实现原理

底层使用MonitorEnter和MonitorExit来控制锁的获取以及释放。提一句，wait和notify也是通过这种方式来进行线程的唤醒和堵塞，所以wait才只能在同步块中进行调用。

锁的分类：无锁、偏向锁、轻量级锁、重量级锁。

下面就是对象头中的Mark Word的存储内容

| 锁状态   | 29 bit 或 61 bit             | 1 bit 是否是偏向锁？       | 2 bit 锁标志位 |
| -------- | ---------------------------- | -------------------------- | -------------- |
| 无锁     |                              | 0                          | 01             |
| 偏向锁   | 线程ID                       | 1                          | 01             |
| 轻量级锁 | 指向栈中锁记录的指针         | 此时这一位不用于标识偏向锁 | 00             |
| 重量级锁 | 指向互斥量（重量级锁）的指针 | 此时这一位不用于标识偏向锁 | 10             |
| GC标记   |                              | 此时这一位不用于标识偏向锁 | 11             |

无锁就是没有锁的意思。

偏向锁：锁总是偏向于第一次获取锁的线程。在锁的对象头的mark word中，有一个记录偏向锁的位置，存放的是线程的ID。如果一个线程遇见锁（synchronized）了，会去检查锁的对象头的偏向锁的记录是不是当前的线程ID，如果是的话，就直接略过锁不用CAS来进入和退出锁，如果不是的话，就表明有线程竞争，那就使用CAS来替换偏向锁记录的线程ID为当前的线程ID，成功了的话就不会进行锁升级，如果失败的话就进行锁升级。

轻量级锁：不存在锁竞争，没有线程堵塞。栈的局部变量表中有存放对象的引用，也可以理解为一种指针。所以在检测到是轻量级锁的情况之后，就用CAS来改变轻量级中指向栈帧的锁记录的指针，如果成功了就表示当前的线程获得到了锁，如果失败了就一直自旋等待获取锁的线程释放锁，但是不会一直自旋，如果自旋了很久就升级成重量级锁。

重量级锁：使用操作系统的互斥量（mutex）实现的

### 锁升级过程

上面都已经说过了，这里概括一下。

1. 一个线程在获取共享资源的时候，会检查锁的对象头的Mark word中的偏向锁存放的是不是自己的线程ID，如果是的话就为偏向锁，如果不是就使用CAS来替换线程ID，如果成功了就不会锁升级，失败了进行锁升级
2. 新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。
3. 

# 2020.6.5 欢聚时代凉经

简历上写了一些大学的必修课，比如操作系统，计算机网络，组成原理

## 操作系统

### 虚拟内存是什么？

多个进程是共享cpu和内存的，所以操作系统使用了虚拟内存来管理内存，防止内存泄漏。虚拟内存就是操作系统对主存概念的抽象。

虚拟内存为每一个进程提供了一个一致的、完整的地址空间，让每一个进程都产生了一种觉得自己是在独享内存的错觉。

虚拟内存有下面三个好处：

+ 把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中按需缓存。
+ 为每一个进程都提供了一个独立的地址空间，保护每一个进程的地址空间不会被别的进程破坏。

### 多核CPU如何保证执行的正确性？

一个程序被执行永远只是一个CPU在执行它

## 计算机网络

### TCP和UDP的区别

+ TCP是可靠传输，UDP不保证可靠传输
+ TCP是面向字节流的，UDP是面向报文的
+ TCP需要连接，UDP不需要连接
+ TCP有拥塞控制，UDP没有
+ TCP是点对点通信，而UDP可以1对1，也可以1对多
+ TCP首部较长并且是变长的，UDP首部只有8个字节并且是定长的

### TCP如何保证可靠传输的

+ 超时重传
+ 分组交换
+ 拥塞控制

### TCP的三次握手和四次挥手

#### 三次握手

客户端发送一个SYN报文（SYN=1），同时会初始化一个序号，这个序号是随机的（seq=x），服务端如果接受到这个SYN的报文会响应给客户端一个ACK报文（ACK=1），并且服务端也会初始化一个随机的序号（seq=y），并且返回的ack（小写的）= 客户端发送的序号+1（ack=x+1），客户端收到服务端的ACK响应报文之后，就可以真正的开始发送数据了，此时也会响应服务端一个ACK报文（ACK=1，ack=y+1）。

#### 为什么需要三次握手（A）

+ 避免历史连接
+ 同步双方的序列号
+ 确定双方有接收和发送报文的能力

#### 如果TCP连接使用两次握手会怎么样？（A）

无法避免历史连接。假设之前连接了一次，客户端向服务端发送SYN包，但是由于网络堵塞，客户端重新发送一个SYN包给服务端，此时网络通畅，服务端发送了一个ACK包，此时连接建立，但是之前的SYN包此时又发送过来了，所以导致又重新建立连接。

#### 如果使用四次握手会怎么样？（A）

不会怎么样，但是三次握手是最佳选择，避免再多一次发送报文浪费资源。

#### 第三次握手失败会怎么样（A）

一般来说如果服务器检测不到客户端发送过来的报文就会重新发送报文，但是在握手的时候，如果第三次握手失败了，并不会重发，而是发送一个RST报文，进入CLOSED状态，防止SYN报文洪范攻击。

#### 四次挥手

客户端发送一个FIN报文，服务端收到这个报文之后发送一个ACK报文，此时服务端可以继续发送数据，如果服务端发送完成之后想关闭连接，会发送一个FIN报文给客户端，客户端收到这个报文之后，此时会开始计时一个2MSL（报文最大存活时间*2）的计时器，并且会响应一个ACK报文给服务端，服务端关闭，到此四次挥手完成。

#### 为什么最后一次需要开启这个计时器？（A）

如果最后一次的客户端发送给服务端的ACK报文丢失或者被堵塞，服务端在一段时间内没有收到客户端传过来的ACK报文，会重新发送FIN报文，此时由于有一个等待时间，所以客户端可以再重发ACK报文，并且重新计时。

如果没有这个等待时间的话，服务端没有收到客户端发来的ACK报文，就会一直等待下去。

还有一个原因是，MSL是报文最大生存时间，如果没有这个时间的话，之前发送的报文由于网络堵塞，可能在下次连接的时候刚好发送到客户端，此时客户端是可能接收这个报文的。

## JAVA

### HashMap的底层数据结构，是线程安全的吗？

Hashmap的底层数据结构是数组+链表+红黑树，并且数组（哈希桶）的默认容量为16，负载因子是0.75，也就是说如果节点数（**整个hashmap键值对数量**不是哈希桶的占用个数）超过了16*0.75个就会扩容。

#### 扩容（A）

扩容是只对哈希桶进行扩容。

扩容的过程是：创建一个长度为原来的数组长度*2的数组，然后将原来的数组元素一个一个rehash放进新的数组，rehash在jdk1.8的时候是采用这种方式：由于每次扩容数组的元素都是2倍增长的，所以新的数组容量比原来的数组容量多了一位而已，如果新增的那一位为0，则该节点在新的数组中的位置和原来数组中的位置一样，否则为原来的数组位置+原来数组长度大小。

比如原来的容量为16，(16-1)=1111，扩容之后的大小为32，(32-1)=11111，然后用原来的hash值&新的容量，如果多出来的那位为1，则为原来的数组位置+原来的数组长度，否则不变。

![](https://pic2.zhimg.com/80/a285d9b2da279a18b052fe5eed69afe9_720w.png)

#### get（A）

根据key计算出hash，然后用这个hash^(n-1)来计算在数组中的位置，比较头节点，如果相等就返回，如果不相等就遍历链表或者红黑树，直到找到对应的key所对应的value

计算hash的方法是：key==null?key.hashcode^(key.hashcode>>16)，这个方法是一个扰动函数，能够减少hash碰撞，能够保留hashcode的高位特征和低位特征，让hash分布均匀，从而降低hash&(n-1)碰撞概率

#### put（A）

首先判断数组是否为空，如果为空的话就进行扩容（初始化长度为16的数组）

如果不为空，就计算hash值并且判断该位置上有没有元素，如果有元素的话，就判断key值是否相等（hashcode和equals），如果相等就直接覆盖，如果不相等就遍历后边的元素，并且使用尾插法进行插入。如果没有元素的话就新建一个节点。如果一条链表的元素个数大于8，那么就转换成红黑树，不过有一个前提就是要整个map的所有键值对的个数都要大于64，不然就执行扩容。红黑树变回链表的条件是元素个数小于等于6个。

### ConcurrentHashMap如何保证线程安全的

底层数据结构在jdk1.8的时候是和hashmap一样的数组+链表+红黑树。保证线程安全的方式是采用了CAS+synchronized来确保线程安全的，取代了jdk1.7中的分段锁的这种方式。

#### put方法保证线程安全的方式（A）

put方法调用的是putval方法，putval方法有三个参数：key、value、onlyIfAbsent：表示只有在key对应的value不存在时才将value加入。

如果给定的key对应的哈希桶为空，使用CAS来设置头节点。

添加节点的时候，需要锁住链表的第一个节点，遍历后边的节点，看是否需要进行红黑树转换，并且插入节点。

#### 扩容（A）

使用一个线程创建新的容器，让多个线程复用。

## Jvm

### 运行时数据区有哪些

### 哪些是线程私有哪些的线程公有的

### 方法区存放的有哪些东西

### 创建一个对象的过程

### 如何知道这个对象是哪个类型的

## MySQL

### mysql的事务的四大特性

### 事务的隔离性有哪一些

### 默认的事务隔离性是什么

可重复读

### 表锁和行锁有什么区别

#### 表锁

表锁有元数据锁和表级锁。

##### 元数据锁

元数据锁不需要显式的加上，每次对表进行CRUD的时候会自动加上元数据读锁，对标的结构进行修改的时候会加上元数据写锁，读锁不会线程互斥的，写锁是线程互斥的

##### 表级锁

显式的执行对这个表的锁操作，语法：lock  table  read/write，读锁不会互斥，写锁会互斥，并且写锁仅仅值能让加上这个锁的线程进行写，其他的线程无法读写。

#### 行锁

行锁是锁住这一行的，有读锁和写锁，读锁不互斥，写锁互斥。

行锁由于有两段锁协议所以只能在事务提交的时候释放，如果数据库的设置auto_commit = 1的话，一个SQL语句就是一个事务，也就是说这样的话一个写语句也会堵塞其他的事务。

## Redis

### 基本的数据结构有哪些

string set hash zset hyperloglog 布隆过滤器

### 布隆过滤器实现的原理

每次添加key的时候使用3个函数，让得到的值余上数组长度，然后将对应的位置置为1，添加就完成了。过滤就反其道而行之，看对应的位置是否为0，有一个为0的话，那么就表示不存在这个key

### 布隆过滤器的使用场景

推送的时候可以使用布隆过滤器来避免推送了用户的浏览历史内容

### string的底层实现

数组，类似于ArrayList的底层实现

## 我问的问题

为什么不问spring的那些东西

### 回答

只要基础好，spring给两天时间就能会，深入的得看源码

# 2020.6.29 招银网络科技一面

## JVM

### 说一下JVM的内存模型

### 垃圾回收的算法有哪些

### 讲一个熟悉的垃圾回收算法

#### GC ROOT对象

+ 本地变量表（存放在虚拟机栈中）中引用的对象
+ 引用类型的静态变量
+ 常量池中引用的对象
+ JVM内部的引用对象（比如一些异常类OutOfMemoryError，Class对象）
+ 被Synchronized上锁的对象

#### 标记清除算法

首先先进行标记阶段，标记有两次标记，第一次看这个对象能否和GC ROOT对象关联起来，如果没有关联就会做上第一次标记，随后看这个对象是否执行finitialize()方法，如果执行过了就没必要执行了，如果没执行的话，就将这个对象放入F-QUEUE。第二次标记的过程，会依次调用队列中的对象的finitialize()方法，如果和GCROOT对象产
生了关联就不会被标记，如果还是没有关联的话就要被清除了。然后对这些被标记上的对象进行清除。

**优点**：实现比较的简单

**缺点**：1.执行效率不稳定，在堆中如果有很多对象都要被清除，那么效率就会下降

​			2.可能产生内存碎片的问题

#### 标记复制算法



### 类加载的过程

### 双亲委派模型

### 自己写的程序由哪个类加载器加载

## MySQL

### 事务的四个属性解释一下

A（原子性）：一个事务中的操作要么一起成功要么一起失败

C（一致性）：事务前后数据的完整性必须保持一致

I（隔离性）：不同事务之间不能相互干扰，事务的隔离级别有：读未提交、读提交、可重复读、可串行化

D（持久性）：事务提交之后就算发生故障也不会影响这个结果

### innodb的默认索引是什么？

B+树

### 为什么会选择B+树？

1. 只有叶子节点存放的是数据，其他的节点存放的都是索引，这样的好处就是一次性读入内存的数据更多
2. 查询效率更稳定
3. B+树的数据都存储在叶子结点中，各个叶子节点有兄弟指针，所以，扫库的时候很方便，只需要扫一遍叶子结点即可

### B+树的缺点

可能产生页分裂，减小存储空间的利用率

由于B+树的特点是叶子节点的一个节点存放了多个数据，如果要插入的数据刚好是在这个满了的节点，就会导致这个节点的数据都分散开来，本来一页能存放的数据，变成了两页存放，所以就会导致页分裂并且空间利用率降低了50%

## Redis

### 常用的数据结构

### 这些数据结构的内部编码有哪些

https://www.cnblogs.com/yangmingxianshen/p/8054094.html

使用object encoding {key} 查看编码

String有 **int**(value是数字，并且不带引号的时候的编码)，**embstr**(字符串比较短的时候的编码)，**raw**(字符串比较长的编码)，如果string超过44字节就从embstr变成raw

Hash有**ziplist**：当field个数比较少且没有大的value时，内部编码为ziplist；**hashtable**：当有value大于64个字节或者当field个数超过512，内部编码会由ziplist变为hashtable

list有**ziplist**：当元素个数较少且没有大元素时，为ziplist；**linkedlist**：当元素个数超过512个或者当某个元素超过64个字节，内部编码变为linkedlist

set有**intset**：整数集合，当元素比较少的时候并且都是整数的时候，内部编码是intset ；**hashtable**：当元素个数超过512个，或者某个元素不为整数的时候，内部编码为hashtable

zset有

### 一般使用Redis干嘛

缓存

## Spring

### springboot 2.x 官方推荐使用构造器注入，为什么？

使用field注入的话，遇到循环依赖会解决不了这个问题

### SpringBoot的启动流程（自己补充的）

1. 从spring.factories中读取监听器
2. 设置环境变量
3. 根据环境变量创建不同的ApplicationContext
4. 设置ApplicationContext
5. 刷新ApplicationContext
6. 设置BeanPostProcessor
7. 调用CommandLineRunner和ApplicationRunner的Run方法

### Spring事务怎么用的？有哪些传播机制

### @Transactional能用在private方法上吗？为什么？

可以加，但是没有意义。

Spring事务是使用AOP实现的，如果加在了private方法上的话，生成的代理对象调用的方法并不会调用到这个方法。

## 设计模式

### 说说你熟悉的设计模式

单例？太简单了。
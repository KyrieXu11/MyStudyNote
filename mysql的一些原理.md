## Mysql有哪些索引结构

hash 和 b+ 

## 为什么hash表、二叉树、AVL树、b-、b+都可以优化查询，mysql选择了b+树

## 为什么需要索引

mysql底层使用的时B+树，mysql索引是放在磁盘上面的，因此每次读取索引时通过IO从磁盘读取。引入索引的目的就是为了减少IO次数，避免慢查询。

## hash

字段值所对应的数组的下标是通过hash算法算出来的，所以，hash表能解决等值查询，如果是范围查询的话，那么就不行了。

![hash_gif_01.gif](https://i.loli.net/2020/03/04/qrcMYCO2Hik6vjE.gif)

通过hash算法，讲字符串转换成对应的数组下标，如果有重复的hash值，就和链表一样，在对应的下标插入一个节点。

所以hash的最理想的使用场景就是等值查询

```sql
select * from table where id = 123;
```

这样的查询走hash索引结构的话，查询会加快。但是如果是范围查询如：

```sql
select * from table where id > 123;
```

hash索引就会显得无能为力了。

## 二叉查找树

![bst_gif_01.gif](https://i.loli.net/2020/03/04/DozpefEA51Y2XJW.gif)

解决hash索引不能排序问题，但是当数据有序时会出现线性排列，树的深度会变得很深，会消耗大量IO。

## AVL树

下面这个是一颗普通的二叉查找树，可以看出来，这样的树，树高很高，而树高的后果，上面也说了，是会导致IO次数增多。

![bst.png](https://i.loli.net/2020/03/05/eaFYSTJ9E4RnOjC.png)

而Avl树就比普通的二叉查找树的树高要低，可以看一下：

![avlt.png](https://i.loli.net/2020/03/05/lRnwLedDc3zfG5s.png)

同样的数据，avl树的树高就比上面的普通的二叉查找树要少的多，“矮胖”的树才能减少IO次数，那么为什么Avl树也不行呢？上面的avl树，在数据量少的时候，看起来还挺好的，但是在数据库里面吧，数据量很大的情况下，树高还是会非常高，而且不仅仅是这个原因，Avl树每个节点只保存了一个**关键字**的长度(如i**nt类型 4byte**)，而在从磁盘读取数据的时候以**一页(4kb**)为单位来进行读取的，所以白白的浪费了4kb-4b=**4092b**的空间。

## B-树

解决平衡二叉树树深度的问题，解决了平衡二叉树读取消耗大量内存空间的问题。

因为B-树每个节点可以存放多个关键字，最大限度的利用了从磁盘读取的内存空间，单节点存放多个关键字同时也大大减少了树的深度。极大的提高了mysql的查询性能。下面就是一个b-树，同样的数据，b-树比上面的avl树的树高还要低。就是因为一**个节点可以存储多个数据**，从而少了一些磁盘IO的浪费

![bt.png](https://i.loli.net/2020/03/05/svxACrDLTWenERJ.png)

B-树还有一个特点，那就是为了解决上面的IO浪费的问题，每次新建节点时，**直接申请一个页的空间**，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node**只需一次I/O**。

但是B-树还是有缺点，B-树对有**范围查找的查询**（如age>20）时采用的还是**中序遍历**，因此也需要多遍历，并且查询性能不稳定。

比如查询（select * from table where id = 222 和 select * from table where id = 223）时在查询效率（耗时）上可能会存在一定的差别，因为B-树还是将关键字，这里为id，存放在根节点和叶节点的，如果运气好，可能id=222这个关键字就在第一个节点，消耗一次IO就找到了，而id=223可能在叶子节点，需要消耗3次IO才能找到。因此B-树对同一条sql语句的查询性能可能会有很大影响。

B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就会成功并结束查询，如果在非叶子节点的情况下，那就会一直查询。

总结一下：b-树对同一条sql语句的查询的影响会有很大的不同

## B+树

B+树：将关键字全部存放在叶子节点(查询更稳定，同一条mysql语句执行效率时相同的，都会消耗3次IO)，将相邻叶子节点的地址保存起来（相比于B-树，对于mysql的范围查找不用再使用中序查找，而是可以直接快读获取到。）下面就是一个b+树，之后叶子节点保存数据，其他的节点都是索引，而且B+树的IO次数稳定是很稳定的。

B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数。

![bplus.png](https://i.loli.net/2020/03/05/dop25tuPSeRLvlK.png)

总结：mysql最终使用B+树为mysql索引的底层实现，mysql维护索引有很大的消耗的，会极大的影响数据库的增、改、删操作，因此建立有用的索引很重要，索引字段所占字节越少，mysql一次读取的关键字也会也多，消耗IO会更少、命中率会更大，查询效率随之也会更高。

而且相对于B-树来说，B+树支持范围查询，更加快捷，所以Mysql选择了B+树

## 锁

锁分为全局锁、表级锁、行锁。

## 全局锁

全局锁是将整个数据库都上锁，所有的非读操作都会被堵塞。通常用来做全库的逻辑备份。也就是把整库每个表都 select 出来存成文本。

### 表级锁

表级锁分为元数据锁和表锁。

#### 表锁

表锁是对表加上读锁或者写锁，如果在某个线程中执行lock table a read，别的线程就只能读表a，如果是lock table b write别的线程对表b什么都干不了

#### 元数据锁

元数据锁不会显式被执行的，当一个线程要对一张表进行CRUD的时候，会自动给这张表加上**元数据读锁**，读锁是不会互斥的，所以多个线程都可以对这张表进行CRUD操作。如果给这张表进行结构上的修改的时候，会自动加上**元数据写锁**，元数据写锁是线程互斥的，因为在改表的结构的时候是不能有数据改动的，此时所有别的线程必须被堵塞。

## 行锁

innodb支持行锁，而MyAism不支持。

行锁有一个两段锁协议，在innodb事务当中，行锁只有在需要的时候才加上，事务提交的时候被释放。所以一个事务在其中有写语句（需要待匹配的字段上有索引）的时候会自动给这一行加上行锁，其他的事务会被堵塞。

### 什么时候走行锁

sex字段是没有索引的

| 事务A                                      | 事务B                              |
| ------------------------------------------ | ---------------------------------- |
| begin;                                     | begin;                             |
| select * from test where sex=1 for update; |                                    |
|                                            | update test set age=2 where sex=2; |

执行完成上面的两个事务，在事务A没有提交的时候，事务B是会堵塞的。

![UraKnx.png](https://s1.ax1x.com/2020/07/16/UraKnx.png)

可以说明现在走的是表锁。

如果待匹配字段是有索引的，效果就会如下：

![UrdTdf.png](https://s1.ax1x.com/2020/07/16/UrdTdf.png)

事务B是没有阻塞的。

## 间隙锁

创建一张表t（id,a,b），执行下面的SQL语句

```sql
insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25)
```

这样就产生了[-∞,0]，[0,5]，[5,10]，[10,15]，[15,20]，[20,25]，[20,+∞]这7个间隙，也就是说在可重复读的情况之下开启两个事务

| 事务A                       | 事务B                       |
| --------------------------- | --------------------------- |
| begin;                      |                             |
| Q1:select * from t;         | begin;                      |
|                             | insert into t values(6,6,6) |
|                             | commit;                     |
| update t set a=7 where id=6 |                             |
| Q2: select * from t;        |                             |

前后查询的数据是不一致的，Q1查到的数据是：id从0~5的所有数据，Q2查询到的数据却是：id从0 ~ 6的所有数据，这样产生了幻读。

而间隙锁就是为了防止这种情况，如果使用

```sql
select * from t where id = 6 for update;
```

这样就锁住了[5,10]这个间隙，这样就不能在这个间隙中插入数据了

下面是一个实例：开启一个事务A，给7~10这个间隙加上锁

![UPcsrn.png](https://s1.ax1x.com/2020/07/06/UPcsrn.png)

开启一个事务B：

尝试插入id=9的数据会被阻塞，但是插入id=6的数据就不会阻塞，正常进行，是因为事务A没有给6之前的间隙加锁，所以是正常插入的。

![UPcjRe.png](https://s1.ax1x.com/2020/07/06/UPcjRe.png)

## 事务

### 四大特性

原子性、一致性、持久性、隔离性。

原子性是事务是一个原子操作，要么一起成功，要么一起失败。

一致性是事务应该从一个一致的状态转换成另一个一致的状态。不能凭空产生数据，也不会凭空减少数据。

持久性是事务一旦提交那么做的修改就是持久化在硬盘上的。

隔离性就是事务之间要有隔离。

### 隔离级别

#### 读未提交

事务之间的操作都是透明的

#### 读提交

只有事务提交之后别的事务才能看到做的修改。会有脏读的隐患

#### 可重复读

一个事务从开始到提交，读到的数据都是一致的。

解决了脏读的问题：在事务执行的时候，另一个事务对数据进行了修改，本事务读取的数据是错误的。

又有幻读的问题，但是innodb使用多版本并发控制解决了这个问题。幻读：在一个范围内读取数据是这么多行，读取完成之后有其他的事务插入了一行，此时再读取这个范围的数据发现多出来了一行。

MySQL默认的事务隔离级别是可重复读。

#### 可串行化

通过加锁来保证事务的串行化

### MVCC(多版本并发控制)

在每一行都会有两个隐藏的列：行的创建时间和行的删除时间。

在可重复读的情况下，每个事务会去搜寻**创建时间比当前事务版本号小**的行以及**删除时间比当前事务版本大或者未定义**的行。

每次插入数据都会将创建时间设置为当前事务的版本号。

每次删除行都会将删除时间设置为当前的事务版本号。

更新的话，就是上面两个行为都会做。

在可重复的隔离级别中有一个规则就是：先读后写，读当前的值，在当前值的基础上修改。

![NEd8Bj.png](https://s1.ax1x.com/2020/06/17/NEd8Bj.png)

事务B最后读出的数据为1，而事务C读出的数据为3。

由于可重复读的隔离条件下，事务总是会找到比当前事务版本号更低或者相等的行数据。事务B没有更新操作从头到尾是不会变的所以读出来的数据k=1。

事务D先更新了表，所以行的系统版本变成了事务D的事务版本

而事务C由于更新，是写操作，按照之前的当前读当前写的规律，所以将k在事务D的基础上设置成了k=3，并且将该行的版本号改成了当前的事务版本，所以最后一个select语句是从当前的事务版本号的行读出来的数据，也就是k=3。
# 放一些可能出现的面试题目

## JVM

## MySQL

### innodb什么时候使用行级锁和什么时候使用表级锁

查询的字段有索引，走行锁，没有索引走表级锁。

## Java

### HashSet的底层原理

底层其实就是个HashMap，key就是add()方法的参数，而value是一个新建的Object对象

### HashSet的注意事项

可能会导致内存泄漏，一个对象在被加入HashSet之后，就不能改变对应的对象的HashCode了，否则不能找到这个对象，从而导致内存泄漏

```java
public class HashSetTest {
    public static void main(String[] args) {
        Set<Person> set = new HashSet<Person>();
        Person p1 = new Person("唐僧", "pwd1", 25);
        Person p2 = new Person("孙悟空", "pwd2", 26);
        Person p3 = new Person("猪八戒", "pwd3", 27);
        set.add(p1);
        set.add(p2);
        set.add(p3);
        System.out.println("总共有:" + set.size() + " 个元素!"); //结果：总共有:3 个元素!  
        p3.setAge(2); 		//修改p3的年龄,此时p3元素对应的hashcode值发生改变  
        set.remove(p3); 	//此时remove不掉，造成内存泄漏  
        set.add(p3);	 	//重新添加，居然添加成功  
        System.out.println("总共有:" + set.size() + " 个元素!"); //结果：总共有:4 个元素!  
        for (Person person : set) {
            System.out.println(person);
        }
    }
}

public class Person {
    private String username;
    private String password;
    private int    age;

    public Person(String username, String password, int age) {
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((password == null) ? 0 : password.hashCode());
        result = prime * result + ((username == null) ? 0 : username.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Person other = (Person) obj;
        if (age != other.age)
            return false;
        if (password == null) {
            if (other.password != null)
                return false;
        } else if (!password.equals(other.password))
            return false;
        if (username == null) {
            if (other.username != null)
                return false;
        } else if (!username.equals(other.username))
            return false;
        return true;
    }

    @Override
    public String toString() {
        return this.username + "-->" + this.password + "-->" + this.age;
    }
}
```

### HashMap和HashTable的区别

1. HashMap线程不安全，后者线程安全
2. HashMap继承自AbstractMap抽象类，而HashTable继承Dictionary抽象类
3. Hashtable的初始长度是11，之后每次扩充容量变为之前的2n+1（n为上一次的长度），而HashMap的初始长度为16，之后每次扩充变为原来的两倍
4. Hashtable直接使用对象的hashCode，HashMap的hash算法是 key.hashcode^(key.hashcode>>>16);



### Spring IOC容器的启动过程

https://juejin.im/post/5da7a0555188257a7306822d

#### 基于XML的方式启动

使用ClasspathXmlApplicationContext启动时

1. 调用父容器的构造方法为容器设置好 Bean 资源加载器
2. 设置传进去的配置文件的路径
3. 刷新容器，此时会对实例对象上锁，防止另外一个ApplicationContext创建的时候再刷新导致线程安全的问题
4. 设置 “正在创建”，校验XML文档
5. 销毁之前的创建的容器，使用DefaultListableBeanFactory创建新的容器
6. 通过loadBeanDefinitions()这个方法将Bean加载到BeanFactory中
7. 使用XmlBeanDefinitionReader调用真正的加载方法，即loadBeanDefinitons()来执行真正的加载
8. 通过XML文档解析器将Bean的配置写入BeanDefinition中，并且放进一个BeanName -> BeanDefinition的Map中去，真正的类加载的过程在之后进行

#### doCreateBean()方法步骤：

1. 开始是单例的话要先清除缓存；

2. 实例化bean，将BeanDefinition转换为BeanWrapper；**createBeanInstance()**

3. 使用MergedBeanDefinitionPostProcessor，Autowired注解就是通过此方法实现类型的预解析；

4. 解决循环依赖问题；

   ```java
   	// 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用
   	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
   
   	// 存放 bean 工厂对象，用于解决循环依赖
   	private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
   
   	// 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖
   	private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
   ```

   ```java
   	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   		// 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用
   		Object singletonObject = this.singletonObjects.get(beanName);
   		// 获取的单例bean为空以及特殊的bean正在创建中
   		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
   			synchronized (this.singletonObjects) {
   				// 没有填充属性的bean，仅仅只是实例化了的对象
   				singletonObject = this.earlySingletonObjects.get(beanName);
   				// 如果这也没找到
   				if (singletonObject == null && allowEarlyReference) {
   					// 从 singletonFactories 中获取 objectFactory
   					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
   					if (singletonFactory != null) {
   						// 从objectFactory中获取object
   						singletonObject = singletonFactory.getObject();
   						this.earlySingletonObjects.put(beanName, singletonObject);
   						this.singletonFactories.remove(beanName);
   					}
   				}
   			}
   		}
   		return singletonObject;
   	}
   ```

   总结上面的代码就是

   1. 先去singletonObjects中找，如果找到了就返回，此时的bean是已经填充好属性的bean了
   2. 如果没找到就去earySingletonObjects中找，如果找到了就返回，此时的bean是实例化但是没有填充属性的bean
   3. 如果没找到就去对应的ObjectFactory中实例化一个，并且将当前的ObjectFactory从map中移除
   4. 如果还没找到的话返回null，此时会抛出异常

5. 填充属性，将属性填充到bean实例中,**populateBean()**

6. 调用**initializeBean**

7. 注册**DisposableBean**；

8. 创建完成并返回

所以综上所述可以得到：

### SpringBean的生命周期

1. 实例化Bean
2. 填充属性
3. 如果bean实现了Aware接口，就会调用不同的aware接口的方法
4. 前置BeanPostProcessor调用，这一步是在初始化之前
5. 检查是否实现了InitializingBean接口和afterPropertiesSet方法，如果都实现了，就调用
6. 检查是否配置了init-method属性，配置了就调用
7. 后置BeanPostProcessor调用
8. 注册必要的Destruction相关回调接口
9. 使用
10. 是否实现了DisposableBean接口，实现了就调用destroy-method方法 ，这一步使用了适配器模式



### SpringBoot的启动流程

1. 开启一个计时器
2. 从Spring.factories文件中加载监听器，发布应用启动开始的事件
3. 设置输入的参数（main方法的args）
4. 配置环境（profile）
5. 根据不同的web环境，创建ApplicationContext，比如如果是servlet环境的话，创建`AnnotationConfigServletWebServerApplicationContext`
6. 预处理ApplicationContext，为刚创建的容器对象做一些初始化工作
7. 刷新ApplicationContext，注册BeanPostProcessor，调用BeanFactory的后置处理器
8. 执行刷新容器后的后置处理逻辑（为空方法）
9. 调用CommandLineRunner和ApplicationRunner接口的Run方法
10. 返回容器对象

### SpringBoot怎么加载Tomcat的

上面的启动流程中

1. 在刷新ApplicationContext的步骤中，调用了refresh()方法
2. 而这个refresh()方法调用了onRefresh()方法，这个方法是交给子类去实现的
3. 而在ServletWebServerApplicationContext中实现了这个方法（onRefresh()）
4. 并且这个子类的实现的方法调用了createWebServer()
5. createWebServer()调用了TomcatServletWebServerFactory的getWebServer()方法
6. getWebServer()返回了一个新建的TomcatWebServer对象
7. 而在这个TomcatWebServer对象的构造方法调用了initialize()方法
8. initlize()方法调用了tomcat的start()方法，启动了Tomcat服务器

### SpringMVC处理流程

![处理流程](https://img2018.cnblogs.com/blog/660329/201909/660329-20190922093835529-1159443997.png)

主要运用了DispatcherServlet，处理流程如下：

1. 请求到了DispatcherServlet之后，会根据路径在HandlerMapping去找到对应的处理器（Handler）和处理器拦截器（HandlerInterceptor），并且返回给DispatcherServlet
2. HandlerMapping会把请求映射为一个Handler处理链即一个Handler，多个HandlerInterceptor，采用了策略模式
3. 返回给DispatcherServlet之后，就去找对应HandlerAdapter，由HandlerAdapter去找对应的控制器即Controller
4. Controller返回ModelAndView给HandlerAdapter，并且返回给Dispatcher
5. 由DispatcherServlet去找视图解析器，返回view
6. DispatcherServlet根据view去寻找视图文件返回给前端

### 一个请求到了SpringBoot是怎么处理的

#### 路径映射

调用接口：HandlerMapping

在 DispatchServlet 中，springboot 注册了一个 HandlerMapping 列表。请求过来时，会循环该列表，来解析url获取handler方法，获取到之后即跳出循环。

#### 参数解析

调用接口：HandlerMethodArgumentResolver
在 InvocableHandlerMethod 中，springboot 注入了一个 HandlerMethodArgumentResolverComposite 对象，该对象中有多个解析器放在列表中，解析参数时同样是循环列表，来找出第一个可以解析的解析器进行解析。

#### 返回处理

调用接口：HandlerMethodReturnValueHandler

在 ServletInvocableHandlerMethod 中，springboot 注入了一个HandlerMethodReturnValueHandlerComposite 对象，该对象中有多个返回值处理器在列表中，处理返回值时，首先同样是循环列表，找到处理器，再进行返回值处理。



### Spring事务失效的几种情况

1. 回滚的时候没有抛出RuntimeException而是其他的异常，回滚失效
2. 





### 过滤器和拦截器的区别

1. 拦截器基于反射实现，过滤器基于函数的回调
2. 拦截器不依赖于servlet容器，而过滤器依赖servlet容器
3. 拦截器不能拦截文件请求，而过滤器可以过滤文件请求
4. 拦截器能获取IOC的bean，而过滤器不行（正常情况下）



### Java创建进程

1. 使用ProcessBuilder的start()方法创建进程
2. 使用Runtime的exec(String cmdarray[])方法创建进程









### 接口和抽象类的区别

## Redis

### 使用list做消息队列会遇到什么问题

如果队列为空，那么使用lpop/rpop 会导致cpu空转，如果有很多客户端都在发送这个指令的话，Redis的QPS会很高。解决办法：让客户端的线程休眠一定的时间。

但是休眠线程之后会导致消息接收有延迟，所以使用阻塞pop也就是brpop/blpop，没有数据会自动休眠，有数据会立刻醒过来。

但是如果阻塞的太久了，redis会认为这个连接是一个闲置连接，会自动断开这个连接，断开之后再使用brpop/blpop会抛出异常。

### Redis的过期策略

Redis会将设置了过期时间的key放在一个字典里面，然后定时遍历（10s）这个字典，删除过期的key

除了定时遍历还会采用惰性删除的方法，惰性删除：在客户端访问一个key的时候，redis检测这个key有没有过期，如果过期了，就会删除，并且告诉客户端这个key过期了。

#### 定期遍历

每10s遍历一次字典

1. 从字典中选取20个key
2. 删除这20个key的过期的key
3. 如果过期的key超过了1/4，就会重复步骤1，当然上面可能会出现死循环，所以redis设置了扫描时间的上限为25s，如果扫描时间超过了25s就会退出扫描。

### Redis的多路复用IO模型

#### 1. select

```c
int select (int n/*  */, fd_set *readfds/* 读文件标识符 */, fd_set *writefds/* 写文件标识符 */, fd_set *exceptfds/* 异常文件标识符 */, struct timeval *timeout/* 超时时间 */);
```

一个socket就是一个fd（文件描述符），而上面的readfds、writefds、exceptfds是位图的数据结构。

假如说fd有5个，且数据分别是 2 1 3 4 5，那么readfds可以表示成 011111，及第一位有数据、第二位有数据、第三位有数据·······，在调用select函数的时候，操作系统会将readfds拷贝一份到内核态，让内核态来进行判断对应的fd有没有数据，有数据就将readfds对应的位置为1，置位完成就返回，当select函数返回后，可以通过遍历fd_set，来找到就绪的描述符

缺点：内核态和用户态拷贝需要开销、bitmap最大是1024位、fd_set不可重用

#### 2.  poll

```c
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
```

```c
struct pollfd{
    int fd;			/* 和上面的fd是一样的 */
    short events;	/* 对fd是写还是读 */
    short revents;	/* 对events的反馈 */
}
```

和select一样，拷贝完成之后在内核态置pollfd.revents，然后返回，对fd_set进行遍历查看哪个是就绪的。

从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

#### 3. epoll

```c
int epoll_create(int size);
```

创建一个监听的数目的大小

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
```

对对应的fd进行操作

## 多线程

### synchronized的底层实现原理

底层使用MonitorEnter和MonitorExit来控制锁的获取以及释放。提一句，wait和notify也是通过这种方式来进行线程的唤醒和堵塞，所以wait才只能在同步块中进行调用。

锁的分类：无锁、偏向锁、轻量级锁、重量级锁。

下面就是对象头中的Mark Word的存储内容

| 锁状态   | 29 bit 或 61 bit             | 1 bit 是否是偏向锁？       | 2 bit 锁标志位 |
| -------- | ---------------------------- | -------------------------- | -------------- |
| 无锁     |                              | 0                          | 01             |
| 偏向锁   | 线程ID                       | 1                          | 01             |
| 轻量级锁 | 指向栈中锁记录的指针         | 此时这一位不用于标识偏向锁 | 00             |
| 重量级锁 | 指向互斥量（重量级锁）的指针 | 此时这一位不用于标识偏向锁 | 10             |
| GC标记   |                              | 此时这一位不用于标识偏向锁 | 11             |

无锁就是没有锁的意思。

偏向锁：锁总是偏向于第一次获取锁的线程。在锁的对象头的mark word中，有一个记录偏向锁的位置，存放的是线程的ID。如果一个线程遇见锁（synchronized）了，会去检查锁的对象头的偏向锁的记录是不是当前的线程ID，如果是的话，就直接略过锁不用CAS来进入和退出锁，如果不是的话，就表明有线程竞争，那就使用CAS来替换偏向锁记录的线程ID为当前的线程ID，成功了的话就不会进行锁升级，如果失败的话就进行锁升级。

轻量级锁：不存在锁竞争，没有线程堵塞。栈的局部变量表中有存放对象的引用，也可以理解为一种指针。所以在检测到是轻量级锁的情况之后，就用CAS来改变轻量级锁中Mark Word中指向栈帧的锁记录的指针，如果成功了就表示当前的线程获得到了锁，如果失败了就一直自旋等待获取锁的线程释放锁，但是不会一直自旋，如果自旋了很久就升级成重量级锁。

重量级锁：使用操作系统的互斥量（mutex）实现的，一个线程获取锁，其他的线程堵塞。

### 锁升级过程

上面都已经说过了，这里概括一下。

1. 一个线程在获取共享资源的时候，会检查锁的对象头的Mark word中的偏向锁存放的是不是自己的线程ID，如果是的话就为偏向锁，如果不是就使用CAS来替换线程ID，如果成功了就不会锁升级，失败了通知之前线程暂停，之前线程将Markword的内容置为空，进行锁升级
2. 使用CAS的方式来替换Mark Word中指向栈帧中锁记录的指针，成功了就表示获取了锁，失败了就一直自旋，如果自旋了很久了就会升级成重量级锁。

### 线程池有几个？对比一下？

| newCachedThreadPool                                   | newFixedThreadPool                                   | newSingleThreadExecutor               | newScheduledThreadPool                         |
| ----------------------------------------------------- | ---------------------------------------------------- | ------------------------------------- | ---------------------------------------------- |
| 不会创建核心线程，线程池最大的大小是Integer.MAX_VALUE | 核心线程数量和总线程数量相等，都是传入的参数nThreads | 有且仅有一个核心线程                  | 创建一个定长线程池，支持定时及周期性任务执行。 |
|                                                       | 只能创建核心线程                                     |                                       |                                                |
| 采用SynchronousQueue                                  | 采用LinkedBlockingQueue                              | 使用了LinkedBlockingQueue（容量很大） | 采用了DelayedWorkQueue                         |

### ThreadPoolExecutor如何做到线程复用的？

ThreadPoolExecutor在创建线程时，会将线程封装成**工作线程worker**,并放入**工作线程组**中，然后这个worker反复从阻塞队列中拿任务去执行。

### 线程池的工作原理

参考银行的业务办理流程。

### 线程池的状态

https://blog.csdn.net/u011389515/article/details/80656813

#### RUNNING

线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 

线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0

#### SHUTDOWN

线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 

调用线程池的**shutdown()**方法时，线程池由RUNNING -> SHUTDOWN

#### STOP

线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 

调用线程池的**shutdownNow()**方法时，线程池由(RUNNING or SHUTDOWN ) -> STOP

#### TIDYING

当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。

ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个**AtomicInteger**类型的变量。

当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理，可以通过重载terminated()函数来实现。

当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。 

#### TERMINATED

线程池彻底终止，就变成TERMINATED状态。 

线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

### 线程的状态

#### 新建 New

处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。

**反复调用同一个线程的start()方法是否可行？**

**假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？**

在start()内部，这里有一个threadStatus的变量。如果它不等于0，调用start()是会直接抛出异常的，在调用一次start()之后，threadStatus的值会改变。所以都不行。

#### 运行态RUNNABLE

包括running和ready状态

#### 阻塞态Block

线程正在等待一个事件结束，比如一个线程遇见synchronized就要等待别的线程释放这个锁

#### 等待态Waiting

调用了wait()方法就是这个状态，如果别的线程没有调用notify()或者notifyAll()就会一直是这个状态

#### 等一段时间Time_Waiting

调用sleep()方法就变成这个状态，等待一段时间之后，拥有了争抢锁的资格。

#### 终止TERMINATED

线程终止状态

线程状态转换图

![UuUgxS.png](https://s1.ax1x.com/2020/07/10/UuUgxS.png)

### 进程的状态

#### 运行Running

当前CPU正在运行此进程

#### 就绪ready 

条件都有，等待CPU来运行了

#### 阻塞、等待wait

等待某个事件完成，没有运行条件

![进程状态变迁图](https://s2.ax1x.com/2019/03/31/AryWDI.png)



### 讲一下JMM

每个线程都有自己的工作空间，需要数据的话就去主存取，改变完成之后就将这个值放回主存，这也就是voliate关键字产生的原因。

线程怎么知道别的线程改变了主存当中的值？

## 计算机网络

[三次握手](#三次握手)

[四次挥手](#四次挥手)

### HTTPS的实现原理

https采用了混合加密的模式：非对称加密和共享公钥加密

1. 首先服务器向证书认证机构发送公钥
2. 认证机构用自己的私钥向服务器部署签名以及证书
3. 服务器和客户端通信的时候就将证书发送至客户端，客户端收到证书之后先使用认证机构的公钥确认证书是否可信，从而确认服务器的公钥是否有效
4. 客户端验证通过之后，使用服务器的公钥对报文进行加密
5. 服务器在收到客户端发送的报文之后，使用私钥对这个报文解密

### HTTPS的通信过程

1. 客户端向服务端发送自己支持的ssl版本和加密算法
2. 服务端收到客户端发送的ssl版本和加密算法，从中筛选出ssl版本和加密算法，并且发送给客户端
3. 服务端发送证书给客户端
4. 最后服务端发送一个报文给客户端表示ssl握手阶段协商结束
5. 客户端验证证书是否正确，提取公钥对本次握手加密，并且返回一个随机的字符串给服务端
6. 接着客户端会发送一个报文给服务端表示之后的报文加密会使用上面的那个字符串进行加密
7. 客户端发送finish报文表示ssl握手结束
8. 服务端收到之后也会发送同样的使用客户端发送的随机字符串进行加密的报文
9. 服务端发送finsh报文表示ssl握手结束

### HTTP的几个版本

#### HTTP/1.1

+ 长连接
+ 管道传输（一个TCP连接对应多个Http请求）

### 键入URL发生了什么？

#### 解析URL

确定服务器的名称和文件名

#### 查询IP地址

将服务器域名传给本地DNS服务器，DNS根据域名返回IP地址，如果本地的DNS中查不到，就找根域名的DNS服务器b，根域名的DNS根据域名返回给本地DNS他应该找哪个DNS服务器c去找，c返回给本地DNS权威DNS服务器的地址，然后本地的DNS又去找权威DNS服务器，才得到IP地址

#### TCP三次握手

[三次握手](#三次握手)

#### 根据IP定位主机

#### 根据MAC地址找到主机

### HTTP的几个方法及总结

#### Put和Post

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

#### Get和Post

+ get主要是为了获取数据，而post是为了提交数据。两者虽然都有给服务器传输数据的功能，但是意义是不一样的。
+ get拼接在url后，post的数据放入body的param内
+ GET的目的是是读取，所以，服务器对应的接口应该有幂等性。即：多次请求的数据，不会因为我的get改变。同时，因为幂等，所以就可以对GET请求的数据做缓存。 
+ get在url上传递参数，默认是ascii，不支持中文，要经过其他配置，而post内的编码可以是unicode-8，支持中文。
+ URL的最大长度是2083个字符，path的部分最长是2048个字符。不过其实是ie8规定的，http协议没有这一点。



## 操作系统

### 多路复用IO

epoll：有事您说，cpu来做，一个CPU对应好多的事件

# 2020.6.5 欢聚时代凉经

简历上写了一些大学的必修课，比如操作系统，计算机网络，组成原理

## 操作系统

### 虚拟内存是什么？

多个进程是共享cpu和内存的，所以操作系统使用了虚拟内存来管理内存，防止内存泄漏。虚拟内存就是操作系统对主存概念的抽象。

虚拟内存为每一个进程提供了一个一致的、完整的地址空间，让每一个进程都产生了一种觉得自己是在独享内存的错觉。

虚拟内存有下面三个好处：

+ 把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中按需缓存。
+ 为每一个进程都提供了一个独立的地址空间，保护每一个进程的地址空间不会被别的进程破坏。

### 多核CPU如何保证执行的正确性？

一个程序被执行永远只是一个CPU在执行它

## 计算机网络

### TCP和UDP的区别

+ TCP是可靠传输，UDP不保证可靠传输
+ TCP是面向字节流的，UDP是面向报文的
+ TCP需要连接，UDP不需要连接
+ TCP有拥塞控制，UDP没有
+ TCP是点对点通信，而UDP可以1对1，也可以1对多
+ TCP首部较长并且是变长的，UDP首部只有8个字节并且是定长的

### TCP如何保证可靠传输的

+ 超时重传
+ 分组交换
+ 拥塞控制

### TCP的三次握手和四次挥手

#### 三次握手

客户端发送一个SYN报文（SYN=1），同时会初始化一个序号，这个序号是随机的（seq=x），服务端如果接受到这个SYN的报文会响应给客户端一个ACK报文（ACK=1），并且服务端也会初始化一个随机的序号（seq=y），并且返回的ack（小写的）= 客户端发送的序号+1（ack=x+1），客户端收到服务端的ACK响应报文之后，就可以真正的开始发送数据了，此时也会响应服务端一个ACK报文（ACK=1，ack=y+1）。

#### 为什么需要三次握手（A）

+ 避免历史连接
+ 同步双方的序列号
+ 确定双方有接收和发送报文的能力

#### 如果TCP连接使用两次握手会怎么样？（A）

无法避免历史连接。假设之前连接了一次，客户端向服务端发送SYN包，但是由于网络堵塞，客户端重新发送一个SYN包给服务端，此时网络通畅，服务端发送了一个ACK包，此时连接建立，但是之前的SYN包此时又发送过来了，所以导致又重新建立连接。

#### 如果使用四次握手会怎么样？（A）

不会怎么样，但是三次握手是最佳选择，避免再多一次发送报文浪费资源。

#### 第三次握手失败会怎么样（A）

一般来说如果服务器检测不到客户端发送过来的报文就会重新发送报文，但是在握手的时候，如果第三次握手失败了，并不会重发，而是发送一个RST报文，进入CLOSED状态，防止SYN报文洪范攻击。

RST报文：用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求

#### 四次挥手

1. 客户端发送一个FIN报文，此时客户端处于FIN_WAIT_1状态
2. 服务端收到这个报文之后发送一个ACK报文，此时服务端可以继续发送数据，服务端处于CLOSED_WAIT状态
3. 客户端收到了服务端发送来的ACK报文会处于FIN_WAIT_2状态
4. 如果服务端发送完成之后想关闭连接，会发送一个FIN报文给客户端，服务端处于LAST_ACK状态
5. 客户端收到这个报文之后，此时会开始计时一个2MSL（报文最大存活时间*2）的计时器，并且会响应一个ACK报文给服务端，并且处于TIME_WAIT状态
6. 服务端收到ACK报文，关闭。
7. 客户端经过了2MSL的时间就关闭了。

#### 为什么最后一次需要开启这个计时器？（A）

如果最后一次的客户端发送给服务端的ACK报文丢失或者被堵塞，服务端在一段时间内没有收到客户端传过来的ACK报文，会重新发送FIN报文，此时由于有一个等待时间，所以客户端可以再重发ACK报文，并且重新计时。

如果没有这个等待时间的话，服务端没有收到客户端发来的ACK报文，就会一直超时重传。

还有一个原因是，MSL是报文最大生存时间，如果没有这个时间的话，之前发送的报文由于网络堵塞，可能在下次连接的时候刚好发送到客户端，此时客户端是可能接收这个报文的。

## JAVA

### HashMap的底层数据结构，是线程安全的吗？

Hashmap的底层数据结构是数组+链表+红黑树，并且数组（哈希桶）的默认容量为16，负载因子是0.75，也就是说如果节点数（**整个hashmap键值对数量**不是哈希桶的占用个数）超过了16*0.75个就会扩容。

#### 扩容（A）

扩容是只对哈希桶进行扩容。

扩容的过程是：创建一个长度为原来的数组长度*2的数组，然后将原来的数组元素一个一个rehash放进新的数组，rehash在jdk1.8的时候是采用这种方式：由于每次扩容数组的元素都是2倍增长的，所以新的数组容量比原来的数组容量多了一位而已，如果新增的那一位为0，则该节点在新的数组中的位置和原来数组中的位置一样，否则为原来的数组位置+原来数组长度大小。

比如原来的容量为16，(16-1)=1111，扩容之后的大小为32，(32-1)=11111，然后用原来的hash值&新的容量，如果多出来的那位为1，则为原来的数组位置+原来的数组长度，否则不变。

![](https://pic2.zhimg.com/80/a285d9b2da279a18b052fe5eed69afe9_720w.png)

#### get（A）

根据key计算出hash，然后用这个hash^(n-1)来计算在数组中的位置，比较头节点，如果相等就返回，如果不相等就遍历链表或者红黑树，直到找到对应的key所对应的value

计算hash的方法是：key==null?key.hashcode^(key.hashcode>>>16)，这个方法是一个扰动函数，能够减少hash碰撞，能够保留hashcode的高位特征和低位特征，让hash分布均匀，从而降低hash&(n-1)碰撞概率

#### put（A）

首先判断数组是否为空，如果为空的话就进行扩容（初始化长度为16的数组）

如果不为空，就计算hash值并且判断该位置上有没有元素，如果有元素的话，就判断key值是否相等（hashcode和equals），如果相等就直接覆盖，如果不相等就遍历后边的元素，并且使用尾插法进行插入。如果没有元素的话就新建一个节点。如果一条链表的元素个数大于8，那么就转换成红黑树，不过有一个前提就是要整个map的所有键值对的个数都要大于64，不然就执行扩容。红黑树变回链表的条件是元素个数小于等于6个。

### ConcurrentHashMap如何保证线程安全的

底层数据结构在jdk1.8的时候是和hashmap一样的数组+链表+红黑树。保证线程安全的方式是采用了CAS+synchronized来确保线程安全的，取代了jdk1.7中的分段锁的这种方式。

#### put方法保证线程安全的方式（A）

put方法调用的是putval方法，putval方法有三个参数：key、value、onlyIfAbsent：表示只有在key对应的value不存在时才将value加入。

如果给定的key对应的哈希桶为空，使用CAS来设置头节点。

添加节点的时候，需要锁住链表的第一个节点，遍历后边的节点，看是否需要进行红黑树转换，并且插入节点。

#### 扩容（A）

使用一个线程创建新的容器，让多个线程复用。

## Jvm

### 运行时数据区有哪些

堆、栈、方法区、本地方法栈、程序计数器

### 哪些是线程私有哪些的线程公有的

堆、方法区是公有的

程序计数器、Java虚拟机栈是线程私有的

### 方法区存放的有哪些东西

类型信息，静态变量，常量，即时编译的代码缓存

### 创建一个对象的过程

1. 检查常量池中是否有这个对象的符号引用
2. 如果没有的话执行类加载的过程，如果有的话，就从堆中分配内存
3. 分配内存完成之后就初始化0值
4. 设置对象头，比如hashcode、年龄信息、是哪个对象的引用等等
5. 执行对象的构造方法
6. 投入使用

### 如何知道这个对象是哪个类型的

在虚拟机栈中的本地方法表中存放了引用类型，通过引用类型来查找，这个引用类型查找的方式有两种。

第一种是引用类型存放的都是直接指针，这样直接指向了Java堆中的对象实例，实例中存放了指向方法区的类型信息的指针。

第二种是使用句柄的方式来查找，栈中存放的引用类型是指向Java堆中的句柄指针，句柄又存放了到堆中对象实例的指针和指向方法区中的类型信息的指针。

## MySQL

### mysql的事务的四大特性

[事务的四个属性解释一下](#事务的四个属性解释一下)

### 事务的隔离性有哪一些

同上

### 默认的事务隔离性是什么

可重复读

### 表锁和行锁有什么区别

#### 表锁

表锁有元数据锁和表级锁。

##### 元数据锁

元数据锁不需要显式的加上，每次对表进行CRUD的时候会自动加上元数据读锁，对标的结构进行修改的时候会加上元数据写锁，读锁不会线程互斥的，写锁是线程互斥的

##### 表级锁

显式的执行对这个表的锁操作，语法：lock  table  read/write，读锁不会互斥，写锁会互斥，并且写锁仅仅值能让加上这个锁的线程进行写，其他的线程无法读写。

#### 行锁

行锁是锁住这一行的，有读锁和写锁，读锁不互斥，写锁互斥。

行锁由于有两段锁协议所以只能在事务提交的时候释放，如果数据库的设置auto_commit = 1的话，一个SQL语句就是一个事务，也就是说这样的话一个写语句也会堵塞其他的事务。

#### 间隙锁

解决幻读的问题。给数据的间隙加上锁，就不让新插入的数据能让其他的事务更新了。

## Redis

### 基本的数据结构有哪些

string set hash zset hyperloglog 布隆过滤器

### 布隆过滤器实现的原理

每次添加key的时候使用3个函数，让得到的值余上数组长度，然后将对应的位置置为1，添加就完成了。过滤就反其道而行之，看对应的位置是否为0，有一个为0的话，那么就表示不存在这个key

### 布隆过滤器的使用场景

推送的时候可以使用布隆过滤器来避免推送了用户的浏览历史内容

### string的底层实现

数组，类似于ArrayList的底层实现

## 我问的问题

为什么不问spring的那些东西

### 回答

只要基础好，spring给两天时间就能会，深入的得看源码

# 2020.6.29 招银网络科技一面

## JVM

### 说一下JVM的内存模型

[运行时数据区有哪些](#运行时数据区有哪些)

### 垃圾回收的算法有哪些

+ 标记清除算法
+ 标记复制算法
+ 标记整理算法

### 讲一个熟悉的垃圾回收算法

#### GC ROOT对象

+ 本地变量表（存放在虚拟机栈中）中引用的对象比如临时变量，参数变量
+ 引用类型的静态变量
+ 常量池中引用的对象
+ JVM内部的引用对象（比如一些异常类OutOfMemoryError，Class对象）
+ 被Synchronized上锁的对象

#### 标记清除算法

首先先进行标记阶段，标记有两次标记，第一次看这个对象能否和GC ROOT对象关联起来，如果没有关联就会做上第一次标记，随后看这个对象是否执行finitialize()方法，如果执行过了就没必要执行了，如果没执行的话，就将这个对象放入F-QUEUE。第二次标记的过程，会依次调用队列中的对象的finitialize()方法，如果和GCROOT对象产
生了关联就不会被标记，如果还是没有关联的话就要被清除了。然后对这些被标记上的对象进行清除。

**优点**：实现比较的简单

**缺点**：1.执行效率不稳定，在堆中如果有很多对象都要被清除，那么效率就会下降

​			2.可能产生内存碎片的问题

#### 标记复制算法

### 类加载的过程

加载->验证->准备->解析->初始化->使用->卸载

#### 加载

1. 通过类名称获取这个类的二进制字节流
2. 将二进制字节流的静态存储结构转化成**方法区**的运行时数据结构
3. 在内存中（java堆）生成一个Class对象，作为方法区的数据的入口

对于数组类而言，数组类本身是JVM直接在内存中动态构造出来的，但是对于数组的元素类型的不同也有不同的策略。

如果元素是引用类型的话，就递归的调用上面的加载过程

如果是基本数据类型的话，就调用引导类加载器加载。

#### 验证

验证的步骤有下面几步：

1. 文件格式验证（比如魔数、版本号等等）
2. 元数据验证（比如这个类是否有父类、这个类的父类是否继承了final修饰的类等语法检查）
3. 字节码验证
4. 符号引用验证

#### 准备

就是给**静态变量**进行初始化0值，如果使用final修饰的话，就会直接赋值，并不会变成0值

#### 解析

1. 类和接口解析
2. 字段解析
3. 方法解析
4. 接口方法解析

#### 初始化

调用\<clint>()的过程，即静态代码块的调用

### 类文件结构（A）

1.魔数和class文件的版本号

2.常量池

3.字段

4.方法

5.属性

6.访问标志

7.运行时注解相关属性

### 双亲委派模型

### 自己写的程序由哪个类加载器加载

## MySQL

### 事务的四个属性解释一下

A（原子性）：一个事务中的操作要么一起成功要么一起失败

C（一致性）：事务前后数据的完整性必须保持一致

I（隔离性）：不同事务之间不能相互干扰，事务的隔离级别有：读未提交、读提交、可重复读、可串行化

D（持久性）：事务提交之后就算发生故障也不会影响这个结果

### innodb的默认索引是什么？

B+树

### 为什么会选择B+树？

1. 只有叶子节点存放的是数据，其他的节点存放的都是索引，这样的好处就是一次性读入内存的数据更多
2. 查询效率更稳定
3. B+树的数据都存储在叶子结点中，各个叶子节点有兄弟指针，所以，扫库的时候很方便，只需要扫一遍叶子结点即可

### B+树的缺点

可能产生页分裂，减小存储空间的利用率

由于B+树的特点是叶子节点的一个节点存放了多个数据，如果要插入的数据刚好是在这个满了的节点，就会导致这个节点的数据都分散开来，本来一页能存放的数据，变成了两页存放，所以就会导致页分裂并空间利用率降低了50%

## Redis

### 常用的数据结构

### 这些数据结构的内部编码有哪些

https://www.cnblogs.com/yangmingxianshen/p/8054094.html

使用object encoding {key} 查看编码

String有 **int**(value是数字，并且不带引号的时候的编码)，**embstr**(字符串比较短的时候的编码)，**raw**(字符串比较长的编码)，如果string超过44字节就从embstr变成raw

Hash有**ziplist**：当field个数比较少且没有大的value时，内部编码为ziplist；**hashtable**：当有value大于64个字节或者当field个数超过512，内部编码会由ziplist变为hashtable

list有**ziplist**：当元素个数较少且没有大元素时，为ziplist；**linkedlist**：当元素个数超过512个或者当某个元素超过64个字节，内部编码变为linkedlist

set有**intset**：整数集合，当元素比较少的时候并且都是整数的时候，内部编码是intset ；**hashtable**：当元素个数超过512个，或者某个元素不为整数的时候，内部编码为hashtable

### 一般使用Redis干嘛

缓存

## Spring

### springboot 2.x 官方推荐使用构造器注入，为什么？

使用field注入的话，遇到循环依赖会解决不了这个问题

### SpringBoot的启动流程（自己补充的）

https://segmentfault.com/a/1190000022119546

1. 开启一个计时器
2. 从Spring.factories文件中加载监听器，发布应用启动开始的事件
3. 设置输入的参数（main方法的args）
4. 配置环境（profile）
5. 根据不同的web环境，创建ApplicationContext，比如如果是servlet环境的话，创建`AnnotationConfigServletWebServerApplicationContext`
6. 预处理ApplicationContext，为刚创建的容器对象做一些初始化工作
7. 刷新ApplicationContext，注册BeanPostProcessor，调用BeanFactory的后置处理器
8. 执行刷新容器后的后置处理逻辑（为空方法）
9. 调用CommandLineRunner和ApplicationRunner接口的Run方法
10. 返回容器对象

### Spring事务怎么用的？有哪些传播机制

使用@Transactional加在方法上

Spring有7种传播机制：

1. 如果存在一个事务则支持这个事务，如果不存在则开启一个事务
2. 总是开启一个事务，如果当前有事务则将这个事务挂起
3. 有事务则支持这个事务，没有就不以事务的方式进行
4. 有事务则支持，没事务抛出异常
5. 总是以非事务的方式进行，挂起任何存在的事务
6. 总是以非事务的方式进行，如果存在事务则抛出异常
7. 如果一个活动的事务存在，则运行在一个嵌套的事务里面，如果没有事务按照第一种方式进行

### @Transactional能用在private方法上吗？为什么？

可以加，但是没有意义。

Spring事务是使用AOP实现的，如果加在了private方法上的话，生成的代理对象调用的方法并不会调用到这个方法。

## 设计模式

### 说说你熟悉的设计模式

单例？太简单了。介绍一下装饰器模式

#### 单例

```java
public class SingletonPattern{
    // 取消指令重排
    private volatile Object instance;
    
    private SingletonPaatern(){
    }
    // 双重判断，线程安全
    public static synchronized Object getInstance(){
        if(instance == null){
            instance = new SingletonPattern();
        }
        return instance;
    }
}
```

#### 工厂

##### 方法工厂

```java
interface Car{
    void name();
}

interface CarFactory{
    Car getCar();
}

class Tesla implements Car{
    @Override
    public void name(){
        
    }
}

class BMW implements Car{
    @Override
    public void name(){
        
    }
}

class TeslaFactory implements CarFactory{
    @Override
    public Car getCar(){
        return new Tesla();
    }
}

class BMWFactory implements CarFactory{
    @Override
    public Car getCar(){
        return new BMW();
    }
}
```





